# 选择排序

## 1、介绍

>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始(末尾)位置，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。

- 工作原理：将待排序数列中最小（或最大）的元素，存放在序列的起始（末尾），直到全部待排序数据排列完成。
- 是不稳定的排序方法

【稳定的排序方法：排序前两个相等的数，在其排序过后的前后位置顺序和排序前相同。

eg：选择排序（不稳定）：[5，==5==，3]->[3，==5==，5] 】

## 2、排序过程

【5，20，6，19，3】

**第一次排序**
选出最大的数值 20 ，与待排数列的最后一位 3，相交换

【==5，20，6，19，3==】->【5，3，6，19，20】

**第二次排序**

【==5，3，6，19，==20】->【5，3，6，19，20】

**第三次排序**

【==5，3，6，==19，20】->【5，3，6，19，20】

**第四次排序**

【==5，3，==6，19，20】->【3，5，6，19，20】

## 3、代码实现

```java
    public static void main(String[] args) {
        //定义一组数据
        int[] array = {5,20,6,19,3};
        //外层循环控制排序的次数
        for (int i = 0;i < array.length - 1;i++){
            //内层循环控制遍历数据的个数
            for (int j = 0;j < array.length - i;j++){
                //用于交换的变量
                int temp = 0;
                //记录最大值的位置
                int index = 0;
                //获取待排数列最大值的下标
                if (array[j] > array[index]){
                    index = j;
                }
                //将最大值移动到待排数列的末尾
                temp = array[index];
                array[index] = array[array.length - i - 1];
                array[array.length - i - 1] = temp;
            }
        }
        for (int i = 0;i < array.length;i++){
            System.out.printf("%4d",array[i]);
        }
    }

输出结果：
      3   5   6  19  20
```

# 插入排序

## 1、介绍

> 插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。

- 工作原理：将一个数据插入到已经排好序的有序数据中

## 2、排序过程

【==5==，20，6，19，3】

**第一次排序**

- 如果插入的数据比第一个数大，那就不管他

- 如果比第一个数小，将第一个数往后退一步，将第二个数插入第一个数去

【==5==，20，6，19，3】->【5，20，6，19，3】

**第二次排序**

- 如果插入的数据比第二位的数大，那就不管它
-  如果比第二位的数小，那就将第二的位置退一个位置，让第三个数和第一位比较
  - 如果第三个数比第一位大，那么将第三个数插入到第二的位置上
  - 如果第三个数比第一位小，那么将第一位后退一步，将第三个数插入到第一的位置上

【==5，20==，6，19，3】->【5，6，20，19，3】

**第三次排序**

【==5，6，20==，19，3】->【5，6，19，20，3】

**第四次排序**

【==5，6，19，20==，3】->【3，5，6，19，20】

## 3、代码实现

```java
    public static void main(String[] args) {
        //定义一组数据
        int[] array = {5,20,6,19,3};
        //i表示插入数据的下标
        for (int i = 1;i < array.length;i++){
            int temp = array[i];
            int j = i - 1;
            //当插入的数据大于当前数据时，直接插入数据即可；当插入数据小于当前数据时，进入循环比较
            while (j >= 0 && array[j] > temp) {
                //将已排数组中的数据向右移一位
                array[j + 1] = array[j];
                //从后往前不断与已排数组中的数据相比较
                j--;
            }
            //将插入数据插入到已排数组中
            array[j + 1] = temp;
        }
        for (int i = 0;i < array.length;i++){
            System.out.printf("%4d",array[i]);
        }
    }

输出结果：
      3   5   6  19  20
```

# 快速排序*

## 1、介绍

> 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以**递归**进行，以此达到整个数据变成有序序列。

- 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小

【**在数组中找一个支点(任意),经过一趟排序后，支点左边的数都要比支点小，支点右边的数都要比支点大！**】

## 2、排序过程

【5，20，6，19，3】

假设以6为支点：

【5，20，6，19，3】->【5，3，==6==，19，20】

通过递归调用，实现排序

## 3、代码实现

```java
    public static void main(String[] args) {
        //定义一组数据
        int[] array = {5,20,6,19,3};
        quickSort(array,0,4);
        for (int i = 0;i < array.length;i++){
            System.out.printf("%4d",array[i]);
        }
    }
    public static void quickSort(int[] arr, int L, int R) {
        //L为待排序数组的左边坐标，R为待排数组的右边坐标
        int i = L;
        int j = R;
        //支点
        int pivot = arr[(L + R) / 2];

        //左右两端进行扫描，只要两端还没有交替，就一直扫描
        while (i <= j) {
            //寻找支点左边的数据，直到比支点大的数
            while (pivot > arr[i])
                i++;
            //寻找支点右边的数据，直到比支点小的数
            while (pivot < arr[j])
                j--;
            //此时已经分别找到了比支点小的数(右边)、比支点大的数(左边)，它们进行交换
            if (i <= j) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
                j--;
            }
        }
        //上面一个while保证了第一趟排序支点的左边比支点小，支点的右边比支点大了。
        //通过递归调用，“左边”再做排序，直到左边剩下一个数
        if (L < j)
            quickSort(arr, L, j);
        //通过递归调用，“右边”再做排序，直到右边剩下一个数(递归出口)
        if (i < R)
            quickSort(arr, i, R);
    }

输出结果：
      3   5   6  19  20
```

